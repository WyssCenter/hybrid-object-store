package api

import (
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"

	"github.com/gigantum/hoss-service/policy"

	"github.com/gigantum/hoss-core/pkg/config"
	"github.com/gigantum/hoss-core/pkg/database"
	"github.com/gigantum/hoss-core/pkg/sync"
)

type notificationQueueSettings struct {
	// MessageType is the class of messages in the queue, currently "bucket_notification" or "api_notification"
	MessageType string `json:"message_type"`
	// SourceEndpoint is the source of event. For bucket events this is the endpoint of the object store
	// (e.g. https://s3.amazonaws.com, "https://hoss.mycompany.com"). For api notification events this
	// is the core service endpoint (e.g. "https://hoss.mycompany.com/core/v1")
	SourceEndpoint string `json:"source_endpoint"`
	// QueueName is the name of the queue
	QueueName string `json:"queue_name"`
	// ExchangeName is the optional name of the exchange (used with amqp)
	ExchangeName string `json:"exchange_name,omitempty"`
	// Region is the optional region (used with sqs)
	Region string `json:"region,omitempty"`
	// NOTE Queue credentials are provided by the user of this data
}

type notificationQueueConfiguration struct {
	// Type is the type of queue ("amqp" or "sqs")
	Type string `json:"type"`
	// Settings is the queue settings struct
	Settings notificationQueueSettings `json:"settings"`
}

// GetNotificationQueue returns the different notification queues that the Sync Service should monitor
// for messages generated by this Core Service
// @Summary Get notification queue info for this core service
// @Schemes
// @Description This endpoint returns the various notification queues that a sync service should
// @Description monitor for events generated by this core service.
// @Description **NOTE: This endpoint is only available to the service account**
// @Tags Service Account
// @Accept json
// @Produce json
// @Success 200 {object} []notificationQueueConfiguration
// @Success 304
// @Failure 400 {object} object{error=string}
// @Failure 401 {object} object{error=string}
// @Failure 403 {object} object{error=string}
// @Failure 404 {object} object{error=string}
// @Failure 500 {object} object{error=string}
// @Security BearerToken
// @Router /configuration/queue [get]
func GetNotificationQueues(c *gin.Context) {
	// NOTE: Since this data is based on the service config file it is only queried once by the sync service
	_, db := getAppConfig(c)
	userInfo := getUserInfo(c)

	if !userInfo.IsService {
		HandleError(c, ErrUnauthorized)
		return
	}

	// Load all of the Bucket Notification queues from the ObjectStores in the database
	var allQueues []notificationQueueConfiguration
	limit := 10
	offset := 0
	for {
		objectStores, err := db.ListObjectStores(limit, offset)
		if err != nil {
			HandleError(c, err)
			return
		}

		if len(objectStores) == 0 {
			break
		}

		for _, objectStore := range objectStores {
			switch objectStore.ObjectStoreType {
			case database.OBJECT_STORE_TYPE_MINIO:
				allQueues = append(allQueues, notificationQueueConfiguration{
					Type: "amqp",
					Settings: notificationQueueSettings{
						MessageType:    "bucket_notification",
						SourceEndpoint: objectStore.Endpoint,
						QueueName:      "bucket_notifications",
						ExchangeName:   "hoss",
					},
				})
			case database.OBJECT_STORE_TYPE_S3:
				splits := strings.Split(objectStore.NotificationArn, ":")
				allQueues = append(allQueues, notificationQueueConfiguration{
					Type: "sqs",
					Settings: notificationQueueSettings{
						MessageType:    "bucket_notification",
						SourceEndpoint: "https://s3.amazonaws.com",
						QueueName:      splits[5],
						Region:         splits[3],
					},
				})
			default:
				logrus.Warn("Cannot generate notification queues for object store type: " + objectStore.ObjectStoreType)
			}
		}

		offset += limit
	}

	// Load all of the API Notification queues from the config file, as we cannot extract this information
	// from the API Sync Exchanges that are created using this information at startup
	cfg := config.Load("")
	for _, queueConfig := range cfg.Queues {
		switch queueConfig.Type {
		case "amqp":
			allQueues = append(allQueues, notificationQueueConfiguration{
				Type: "amqp",
				Settings: notificationQueueSettings{
					MessageType:    "api_notification",
					SourceEndpoint: getCoreServiceEndpoint(),
					QueueName:      "api_notifications",
					ExchangeName:   "hoss",
				},
			})
		case "sqs":
			var queueSettings config.SQSQueueConfig
			if err := config.UnmarshalSettings(queueConfig.Settings, &queueSettings); err != nil {
				HandleError(c, err)
				return
			}

			allQueues = append(allQueues, notificationQueueConfiguration{
				Type: "sqs",
				Settings: notificationQueueSettings{
					MessageType:    "api_notification",
					SourceEndpoint: getCoreServiceEndpoint(),
					QueueName:      queueSettings.QueueName,
					Region:         queueSettings.Region,
				},
			})
		default:
			logrus.Warn("Cannot generate notification queues for queue type: " + queueConfig.Type)
		}
	}

	c.JSON(http.StatusOK, allQueues)
}

// @Description The complete information for a sync configuration between two namespaces
type fullSyncConfiguration struct {
	SyncType string `json:"sync_type"`

	SourceCoreService string            `json:"source_core_service"`
	SourceNamespace   string            `json:"source_namespace"`
	SourcePolicies    map[string]string `json:"source_policies"`

	TargetCoreService string `json:"target_core_service"`
	TargetNamespace   string `json:"target_namespace"`
}

// GetSyncConfiguration returns the SyncConfiguration data needed by the Sync Service
// @Summary Get namespace sync configurations
// @Schemes
// @Description Fetches all the sync configuration information required by the sync service to configure workers
// @Description If-Modified-Since HTTP header to determine if there has been a change
// @Description in the data since the last poll by the Sync Service. If there has been
// @Description no change since the last poll a HTTP 304 Not Modified response is
// @Description returned to the caller of this API. If there has been a change then
// @Description the data is queried, organized, and returned as normal
// @Description **NOTE: This endpoint is only available to the service account**
// @Tags Service Account
// @Accept json
// @Produce json
// @Header  200 string  Last-Modified  "Datetime of the last sync config modification"
// @Success 200 {object} []fullSyncConfiguration
// @Success 304
// @Failure 400 {object} object{error=string}
// @Failure 401 {object} object{error=string}
// @Failure 403 {object} object{error=string}
// @Failure 404 {object} object{error=string}
// @Failure 500 {object} object{error=string}
// @Security BearerToken
// @Router /configuration/sync [get]
func GetSyncConfiguration(c *gin.Context) {
	_, db := getAppConfig(c)
	userInfo := getUserInfo(c)

	if !userInfo.IsService {
		HandleError(c, ErrUnauthorized)
		return
	}

	// The sync_configuration_meta.last_updated / GetLastSyncUpdated value
	// is maintained by the Postgres database using a stored procedure and
	// triggers. The triggers call the stored procedure, which updates the
	// last_updated value with the current database timestamp, when there
	// is a CREATE or DELETE on the sync_configurations table or when there
	// is a DELETE or SET sync_enabled on the dataset table.
	//
	// The last_updated value reflects the timestamp of the last change to
	// the sync configuration information. The value is compared against the
	// If-Modified-Since HTTP header to determine if there has been a change
	// in the data since the last poll by the Sync Service. If there has been
	// no change since the last poll a HTTP 304 Not Modified response is
	// returned to the caller of this API. If there has been a change then
	// the data is queried, organized, and returned as normal

	lastUpdate, err := db.GetLastSyncUpdated()
	if err != nil {
		HandleError(c, err)
		return
	}
	lastUpdateStr := lastUpdate.Format(time.RFC1123)

	ifModified := c.GetHeader("If-Modified-Since")
	if ifModified != "" {
		since, err := time.Parse(time.RFC1123, ifModified)
		if err != nil {
			HandleError(c, err)
			return
		}

		if since.After(lastUpdate) {
			c.Header("Last-Modified", lastUpdateStr)
			c.Status(http.StatusNotModified)
			return
		}
	}

	configs, err := db.GetSyncConfigurations()
	if err != nil {
		HandleError(c, err)
		return
	}

	fullConfigs := []fullSyncConfiguration{}
	for _, config := range configs {
		policies, err := db.GetSyncEnabledPolicies(config.SourceNamespace)
		if err != nil {
			HandleError(c, err)
			return
		}

		fullConfigs = append(fullConfigs, fullSyncConfiguration{
			SyncType:          config.SyncType,
			SourceCoreService: getCoreServiceEndpoint(),
			SourceNamespace:   config.SourceNamespace.Name,
			SourcePolicies:    policies,
			TargetCoreService: config.TargetCoreService,
			TargetNamespace:   config.TargetNamespace,
		})
	}

	c.Header("Last-Modified", lastUpdateStr)
	c.JSON(http.StatusOK, fullConfigs)
}

// @Description Input parameters to configure a sync relationship between namespaces
type syncNamespaceTarget struct {
	// TargetCoreService is the url to the core service that contains the namespace to which you
	// are linking this namespace. It can be the same or different server. (e.g. https://hoss.mycompany.com/core/v1)
	TargetCoreService string `json:"target_core_service" binding:"required"`
	// TargetNamespace is the name of the namespace to which you are linking this namespace
	TargetNamespace string `json:"target_namespace"`
	// SyncType is the type of sync relationship to configure ('simplex' or 'duplex')
	SyncType string `json:"sync_type" binding:"required"`
}

// EnableSyncNamespace enables synchronization of a namespace
// @Summary Enable synchronization of this namespace
// @Schemes
// @Description Configure synchronization for this namespace, enabling datasets to be configured for sync
// @Description Note: Currently in the UI we only support a single sync target, but the system
// @Description could in theory support a multi-way sync configuration between more than 2 namespaces.
// @Tags Namespace
// @Accept json
// @Produce json
// @Param   name   path      string  true  "Namespace Name"
// @Param	syncNamespaceTarget		body	api.syncNamespaceTarget	true	"Namespace Sync Target"
// @Success 204
// @Failure 400 {object} object{error=string}
// @Failure 401 {object} object{error=string}
// @Failure 403 {object} object{error=string}
// @Failure 404 {object} object{error=string}
// @Failure 500 {object} object{error=string}
// @Security BearerToken
// @Router /namespace/{name}/sync [put]
func EnableSyncNamespace(c *gin.Context) {
	_, db := getAppConfig(c)
	userInfo := getUserInfo(c)

	if isAdmin := validateAdmin(userInfo.Role); !isAdmin {
		HandleError(c, ErrUnauthorized)
		return
	}

	namespaceName := c.Param("namespace")

	// Load the specified namespace
	namespace, err := db.GetNamespace(namespaceName)
	if err != nil {
		HandleError(c, err)
		return
	}

	var input syncNamespaceTarget
	err = c.BindJSON(&input)
	if err != nil {
		err := fmt.Errorf("could not BindJSON input: %w", err)
		HandleError(c, err)
		return
	}

	// default to the same namespace name for the target
	if input.TargetNamespace == "" {
		input.TargetNamespace = namespaceName
	}

	currentStore, err := getStoreByName(getStores(c), namespace.ObjectStore.Name)
	if err != nil {
		HandleError(c, err)
		return
	}

	// Verify that there is an API Sync Exchange defined for the namespace
	ase, ok := c.Get("apiSyncExchange")
	if !ok {
		err := errors.New("Failed to load apiSyncExchange in context")
		HandleError(c, err)
		return
	}

	exchanges := ase.(map[string]sync.ApiSyncExchange)
	_, ok = exchanges[namespace.ObjectStore.Name]
	if !ok {
		err := errors.New("no API sync exchange defined for the namespace")
		HandleError(c, err)
		return
	}

	// Note: This will mutate the sync_configuration_meta.last_updated cell with the current timestamp, if the query succeeds
	err = db.CreateSyncConfiguration(namespace, input.TargetCoreService, input.TargetNamespace, input.SyncType)
	if err == database.ErrExists {
		c.Status(http.StatusNoContent)
		return
	} else if err != nil {
		HandleError(c, err)
		return
	}

	// If it is a duplex configuration, enable sync on the target namespace
	if input.SyncType == database.SYNC_TYPE_DUPLEX {
		err = sync.SyncNamespaceHandler(c, currentStore, namespace, input.TargetCoreService, input.TargetNamespace)
		if err != nil {
			HandleError(c, err)
			return
		}
	}

	c.Status(http.StatusNoContent)
}

// GetSyncNamespace gets the synchronization status for a namespace
// @Summary Get synchronization configuration for a namespace
// @Schemes
// @Description Get the synchronization configuration of a namespace as a set of sync targets
// @Tags Namespace
// @Accept json
// @Produce json
// @Param        name   path      string  true  "Namespace Name"
// @Success 200 {object} []database.SyncConfiguration
// @Failure 400 {object} object{error=string}
// @Failure 401 {object} object{error=string}
// @Failure 403 {object} object{error=string}
// @Failure 404 {object} object{error=string}
// @Failure 500 {object} object{error=string}
// @Security BearerToken
// @Router /namespace/{name}/sync [get]
func GetSyncNamespace(c *gin.Context) {
	_, db := getAppConfig(c)

	namespaceName := c.Param("namespace")

	// Load the specified namespace
	namespace, err := db.GetNamespace(namespaceName)
	if err != nil {
		HandleError(c, err)
		return
	}

	syncTargets, err := db.GetNamespaceSyncTargets(namespace)
	if err != nil {
		HandleError(c, err)
		return
	}

	c.JSON(http.StatusOK, syncTargets)
}

// DisableSyncNamespace disables synchronization of a namespace
// @Summary Disable synchronization for a namespace
// @Schemes
// @Description Remove the synchronization configuration for a sync target from the namespace
// @Description Note: Currently in the UI we only support a single sync target, but the system
// @Description could in theory support a multi-way sync configuration between more than 2 namespaces.
// @Tags Namespace
// @Accept json
// @Produce json
// @Param        name   path      string  true  "Namespace Name"
// @Param	syncNamespaceTarget		body	api.syncNamespaceTarget	true	"Namespace Sync Target"
// @Success 204
// @Failure 400 {object} object{error=string}
// @Failure 401 {object} object{error=string}
// @Failure 403 {object} object{error=string}
// @Failure 404 {object} object{error=string}
// @Failure 500 {object} object{error=string}
// @Security BearerToken
// @Router /namespace/{name}/sync [delete]
func DisableSyncNamespace(c *gin.Context) {
	_, db := getAppConfig(c)
	userInfo := getUserInfo(c)

	if isAdmin := validateAdmin(userInfo.Role); !isAdmin {
		HandleError(c, ErrUnauthorized)
		return
	}

	namespaceName := c.Param("namespace")

	// Load the specified namespace
	namespace, err := db.GetNamespace(namespaceName)
	if err != nil {
		HandleError(c, err)
		return
	}

	var input syncNamespaceTarget
	err = c.BindJSON(&input)
	if err != nil {
		HandleError(c, err)
		return
	}

	// default to the same namespace name for the target
	if input.TargetNamespace == "" {
		input.TargetNamespace = namespaceName
	}

	// Note: This will mutate the sync_configuration_meta.last_updated cell with the current timestamp, if the query succeeds
	err = db.DeleteSyncConfiguration(namespace, input.TargetCoreService, input.TargetNamespace)
	if err != nil {
		HandleError(c, err)
		return
	}

	c.Status(http.StatusNoContent)
}

// GetSyncDataset returns if the dataset is enabled to send bucket notification events
// @Summary Check if synchronization is enabled for a dataset.
// @Schemes
// @Description Check if synchronization is enabled for a dataset. To get sync type, fetch the dataset itself
// @Tags Dataset
// @Accept json
// @Produce json
// @Param	namespaceName   path      string  true  "Namespace Name"
// @Param	datasetName   path      string  true  "Dataset Name"
// @Success 200 {boolean} boolean
// @Failure 400 {object} object{error=string}
// @Failure 401 {object} object{error=string}
// @Failure 403 {object} object{error=string}
// @Failure 404 {object} object{error=string}
// @Failure 500 {object} object{error=string}
// @Security BearerToken
// @Router /namespace/{namespaceName}/dataset/{datasetName}/sync [get]
func GetSyncDataset(c *gin.Context) {
	_, db := getAppConfig(c)

	namespaceName := c.Param("namespace")
	namespace, err := db.GetNamespace(namespaceName)
	if err != nil {
		HandleError(c, err)
		return
	}

	datasetName := c.Param("name")
	dataset, err := db.GetDataset(namespace, datasetName)
	if err != nil {
		HandleError(c, err)
		return
	}

	c.JSON(http.StatusOK, dataset.SyncEnabled)
}

type syncDatasetInput struct {
	// SyncType is the type of sync relationship to use ('simplex' or 'duplex')
	SyncType string `json:"sync_type" binding:"required"`
	// A sync policy JSON document stringified
	SyncPolicy string `json:"sync_policy"`
}

// EnableSyncDataset starts sending bucket notifications for the dataset
// @Summary Enable synchronization for a dataset
// @Schemes
// @Description Enable synchronization enabled for a dataset. The namespace must have synchronization configured.
// @Description If the namespace has duplex syncing enabled, you can set the dataset to either duplex or simplex.
// @Description If the namespace has simplex syncing enabled, you can only set the dataset to simplex.
// @Description The optional sync policy can be used to specify additional criteria when syncing data. If omitted, the
// @Description default policy will be used, which will sync all PUT/DELETE operations.
// @Tags Dataset
// @Accept json
// @Produce json
// @Param	syncDatasetInput		body	api.syncDatasetInput	true	"Dataset Sync Input"
// @Param	namespaceName   path      string  true  "Namespace Name"
// @Param	datasetName   path      string  true  "Dataset Name"
// @Success 204
// @Failure 400 {object} object{error=string}
// @Failure 401 {object} object{error=string}
// @Failure 403 {object} object{error=string}
// @Failure 404 {object} object{error=string}
// @Failure 500 {object} object{error=string}
// @Security BearerToken
// @Router /namespace/{namespaceName}/dataset/{datasetName}/sync [put]
func EnableSyncDataset(c *gin.Context) {
	_, db := getAppConfig(c)

	userInfo := getUserInfo(c)

	if privileged := validatePrivileged(userInfo.Role); !privileged {
		HandleError(c, ErrUnauthorized)
		return
	}

	var input syncDatasetInput
	err := c.BindJSON(&input)
	if err != nil {
		HandleError(c, err)
		return
	}

	// If no policy is provided, we default to the open policy
	if input.SyncPolicy == "" {
		input.SyncPolicy = policy.DefaultOpenPolicy
	}

	_, err = policy.Parse(input.SyncPolicy)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("problem parsing sync_policy document: %s", err.Error())})
		return
	}

	namespaceName := c.Param("namespace")
	namespace, err := db.GetNamespace(namespaceName)
	if err != nil {
		HandleError(c, err)
		return
	}

	datasetName := c.Param("name")
	dataset, err := db.GetDataset(namespace, datasetName)
	if err != nil {
		HandleError(c, err)
		return
	}

	// Check to see if sync is already enabled
	isUpdate := dataset.SyncEnabled

	currentStore, err := getStoreByName(getStores(c), namespace.ObjectStore.Name)
	if err != nil {
		HandleError(c, err)
		return
	}

	// Verify that there is an API Sync Exchange defined for the namespace
	ase, ok := c.Get("apiSyncExchange")
	if !ok {
		err := errors.New("Failed to load apiSyncExchange in context")
		HandleError(c, err)
		return
	}

	exchanges := ase.(map[string]sync.ApiSyncExchange)
	_, ok = exchanges[namespace.ObjectStore.Name]
	if !ok {
		err := errors.New("no API sync exchange defined for the namespace")
		HandleError(c, err)
		return
	}

	// Note: This will mutate the sync_configuration_meta.last_updated cell with the current timestamp, if the query succeeds
	err = db.SetDatasetSync(dataset, true, input.SyncType, input.SyncPolicy)
	if err != nil {
		HandleError(c, err)
		return
	}

	// TODO - add a transaction to this request?
	// Make sure that the target dataset is / has been created & the policy is up to date
	// Only call this when the request is coming from the user! If the request is coming from
	// the sync service, it is for the "target".
	userAgent := c.GetHeader("User-Agent")
	if userAgent != "exec-env/hoss-sync-service" {
		err = sync.SyncDatasetHandler(c, currentStore, namespace, dataset, input.SyncPolicy, isUpdate)
		if err != nil {
			HandleError(c, err)
			return
		}
	}

	c.Status(http.StatusNoContent)
}

// DisableSyncDataset disables synchronization for a dataset
// @Summary Disable synchronization for a dataset
// @Schemes
// @Description Disable synchronization enabled for a dataset. This will turn off syncing, but the
// @Description dataset metadata will continue to be indexed.
// @Tags Dataset
// @Accept json
// @Produce json
// @Param	namespaceName   path      string  true  "Namespace Name"
// @Param	datasetName   path      string  true  "Dataset Name"
// @Success 204
// @Failure 400 {object} object{error=string}
// @Failure 401 {object} object{error=string}
// @Failure 403 {object} object{error=string}
// @Failure 404 {object} object{error=string}
// @Failure 500 {object} object{error=string}
// @Security BearerToken
// @Router /namespace/{namespaceName}/dataset/{datasetName}/sync [delete]
func DisableSyncDataset(c *gin.Context) {
	_, db := getAppConfig(c)

	userInfo := getUserInfo(c)

	if privileged := validatePrivileged(userInfo.Role); !privileged {
		HandleError(c, ErrUnauthorized)
		return
	}

	namespaceName := c.Param("namespace")
	namespace, err := db.GetNamespace(namespaceName)
	if err != nil {
		HandleError(c, err)
		return
	}

	datasetName := c.Param("name")
	dataset, err := db.GetDataset(namespace, datasetName)
	if err != nil {
		HandleError(c, err)
		return
	}

	// Check to see if sync is already disabled
	if !dataset.SyncEnabled {
		c.Status(http.StatusNoContent)
		return
	}

	// Note: This will mutate the sync_configuration_meta.last_updated cell with the current timestamp, if the query succeeds
	err = db.SetDatasetSync(dataset, false, "", "")
	if err != nil {
		HandleError(c, err)
		return
	}

	c.Status(http.StatusNoContent)
}
